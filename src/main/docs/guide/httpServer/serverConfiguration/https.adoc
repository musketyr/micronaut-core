The Micronaut framework supports HTTPS out of the box. By default, HTTPS is disabled and all requests are served using HTTP. To enable HTTPS support, define TLS material using named certificate providers and reference them from your SSL configuration. See <<certificates, Certificate providers>> for details.

.HTTPS Configuration Example (self-signed for development)
[configuration]
----
micronaut:
  server:
    ssl:
      enabled: true
      # Reference the named provider below
      key-name: cert-a

  certificate:
    self-signed:
      # Declare a self-signed provider named "cert-a"
      cert-a: ""
----
- The Micronaut framework will create a self-signed certificate.

TIP: By default, a Micronaut application with HTTPS support starts on port `8443` but you can change the port with the property `micronaut.server.ssl.port`.

For generating self-signed certificates, the Micronaut HTTP server will use netty-pkitesting, which requires this dependency:

dependency:io.netty:netty-pkitesting[scope="runtimeOnly"]

WARNING: This configuration will generate a warning in the browser.

== Using a valid X.509 certificate (PEM)

It is also possible to configure a Micronaut application to use an existing valid x509 certificate, for example one created with https://letsencrypt.org/[Let's Encrypt]. You will need the `server.crt` and `server.key` files.

.HTTPS Configuration Example
[configuration]
----
micronaut:
  server:
    ssl:
      enabled: true
      key-name: cert-a

  certificate:
    file:
      cert-a:
        format: pem
        path: server.key
        certificate-path: server.crt
----

With this configuration, if we start a Micronaut application and connect to `https://localhost:8443` we still see the warning in the browser, but if we inspect the certificate we can check that it is the one generated by Let's Encrypt.

image::https-certificate.jpg[]

Finally, we can test that the certificate is valid for the browser by adding an alias to the domain in `/etc/hosts` file:

[source,bash]
----
$ cat /etc/hosts
...
127.0.0.1   my-domain.org
...
----

Now we can connect to `https://my-domain.org:8443`:

image::https-valid-certificate.jpg[]

== Using a PKCS#12 key store

The more traditional approach to managing certificates in Java is with a key store, either in PKCS#12 or the older JKS format. You can convert your PEM files to PKCS#12 as follows:

[source,bash]
----
$ openssl pkcs12 -export \
                 -in server.crt \ # <1>
                 -inkey server.key \ # <2>
                 -out server.p12 \ # <3>
                 -name someAlias \ <4>
                 -chain -CAfile ca.crt -caname root
----
<1> The original `server.crt` file
<2> The original `server.key` file
<3> The `server.p12` file to create
<4> The alias for the certificate

Reference the PKCS#12 in a provider and point SSL to it:

.HTTPS Configuration Example
[configuration]
----
micronaut:
  server:
    ssl:
      enabled: true
      key-name: cert-a

  certificate:
    resource:
      cert-a:
        resource: classpath:server.p12
        password: mypassword
        # format: pkcs12  # optional, auto-detected
----
- Specify the `p12` file path
- Also provide the `password` defined during the export

== Using a JKS key store

You can optionally convert the `p12` store to a JKS one:

[source,bash]
----
$ keytool -importkeystore \
          -deststorepass newPassword -destkeypass newPassword \ # <1>
          -destkeystore server.keystore \ # <2>
          -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass mypassword \ # <3>
          -alias someAlias # <4>
----
<1> It is necessary to define the password for the keystore
<2> The file to create
<3> The PKCS12 file created previously, and the password defined during the creation
<4> The alias used before

WARNING: If either `srcstorepass` or `alias` are not the same as defined in the `p12` file, the conversion will fail.

Now modify your configuration:

.HTTPS Configuration Example
[configuration]
----
micronaut:
  server:
    ssl:
      enabled: true
      key-name: cert-a

  certificate:
    resource:
      cert-a:
        resource: classpath:server.keystore
        password: newPassword
        # format: jks  # optional, auto-detected
----

Start Micronaut, and the application will run on `https://localhost:8443` using the certificate in the keystore.

== Refreshing/Reloading HTTPS Certificates

Keeping HTTPS certificates up-to-date after expiry can be a challenge. A great solution to this is https://en.wikipedia.org/wiki/Automated_Certificate_Management_Environment[Automated Certificate Management Environment] (ACME) and the https://micronaut-projects.github.io/micronaut-acme/latest/guide/index.html[Micronaut ACME Module] which provides support for automatically refreshing certificates from a certificate authority.

If the use of a certificate authority is not possible, and you need to manually update certificates from disk then you should use the <<certificates, file-based certificate provider>>. As long as the underlying file system supports file watching, the provider will automatically recognize an updated key or certificate file.
